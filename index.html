<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Saber Teacher Dashboard</title>
    <link rel="icon" type="image/png" href="https://placehold.co/32x32/007bff/ffffff?text=S">
    <script src="https://cdn.tailwindcss.com?plugins=forms,typography,aspect-ratio,line-clamp"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Sortable/1.15.0/Sortable.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <style>
        /* Custom scrollbar for webkit browsers */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: #a0aec0; /* gray-400 */
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096; /* gray-500 */
        }

        /* SortableJS dragging style */
        .sortable-ghost {
            opacity: 0.4;
            background-color: #bee3f8; /* blue-200 */
        }

        /* Ensure icons are sized correctly */
        .lucide {
            width: 1em;
            height: 1em;
            display: inline-block;
            vertical-align: middle;
        }

        /* Style for the placeholder when no screenshot is available */
        .screenshot-placeholder {
            background-color: #e2e8f0; /* coolGray-200 */
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
            color: #64748b; /* coolGray-500 */
            font-size: 0.8rem;
            height: 100%;
            aspect-ratio: 16 / 9;
            border-radius: inherit; /* Inherit border radius from parent */
        }

        /* Prevent image stretching and ensure aspect ratio */
        .student-screenshot-img {
            object-fit: cover;
            width: 100%;
            height: 100%;
            aspect-ratio: 16 / 9;
            border-radius: inherit; /* Inherit border radius from parent */
        }

        /* Modal styles */
        .modal-backdrop {
            position: fixed;
            inset: 0;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 40;
            display: flex; /* Use flex for centering */
            align-items: center;
            justify-content: center;
        }
        .modal {
            background-color: white;
            border-radius: 0.5rem; /* rounded-lg */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-xl */
            max-height: 90vh;
            display: flex;
            flex-direction: column;
            overflow: hidden; /* Prevent content spill */
            width: 91.666667%; /* w-11/12 */
        }
        @media (min-width: 768px) { /* md */
            .modal { width: 75%; } /* w-3/4 */
        }
        @media (min-width: 1024px) { /* lg */
            .modal { width: 66.666667%; } /* w-2/3 */
        }
        @media (min-width: 1280px) { /* xl */
             .modal { max-width: 64rem; } /* max-w-4xl */
        }

        /* Mobile Sidebar */
        @media (max-width: 768px) {
            #sidebar {
                transform: translateX(-100%);
                transition: transform 0.3s ease-in-out;
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 60; /* Above modal backdrop */
                width: 250px;
            }
            #sidebar.open {
                transform: translateX(0);
            }
            #sidebar-backdrop {
                display: none; /* Hidden by default */
                position: fixed;
                inset: 0;
                background-color: rgba(0, 0, 0, 0.5);
                z-index: 55; /* Below sidebar, above content */
            }
            #sidebar.open + #sidebar-backdrop {
                display: block; /* Show backdrop when sidebar is open */
            }
        }

        /* Custom button style */
        .btn {
            @apply inline-flex items-center justify-center px-4 py-2 border border-transparent text-sm font-medium rounded-md shadow-sm focus:outline-none focus:ring-2 focus:ring-offset-2;
        }
        .btn-primary {
            @apply text-white bg-blue-600 hover:bg-blue-700 focus:ring-blue-500;
        }
        .btn-secondary {
            @apply text-gray-700 bg-white hover:bg-gray-50 border-gray-300 focus:ring-indigo-500;
        }
         .btn-danger {
            @apply text-white bg-red-600 hover:bg-red-700 focus:ring-red-500;
        }
        .btn-success {
            @apply text-white bg-green-600 hover:bg-green-700 focus:ring-green-500;
        }
        .btn-warning {
             @apply text-white bg-yellow-500 hover:bg-yellow-600 focus:ring-yellow-400;
        }
        .btn-icon {
             @apply p-2 rounded-md text-gray-500 hover:text-gray-700 hover:bg-gray-100 focus:outline-none focus:ring-2 focus:ring-inset focus:ring-blue-500;
        }
        .btn-icon-sm {
             @apply p-1 rounded text-gray-400 hover:text-gray-600 focus:outline-none focus:ring-1 focus:ring-offset-1 focus:ring-blue-400;
        }

        /* Active nav link style */
        .nav-link.active {
            @apply bg-blue-50 text-blue-700 font-semibold;
        }
        .nav-link:not(.active) {
             @apply text-gray-600 hover:bg-gray-100 hover:text-gray-900;
        }

        /* Input field base style */
        .input-field {
             @apply block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 sm:text-sm;
        }
    </style>
</head>
<body class="bg-gray-100 font-sans flex h-screen overflow-hidden antialiased">

    <aside id="sidebar" class="bg-white w-64 h-full shadow-lg flex flex-col md:relative fixed md:translate-x-0">
        <div class="p-4 border-b flex items-center justify-between h-16">
            <h1 class="text-2xl font-bold text-blue-600">Saber</h1>
            <button id="close-sidebar-btn" class="md:hidden btn-icon">
                <i data-lucide="x" class="lucide h-5 w-5"></i>
            </button>
        </div>

        <nav class="flex-1 overflow-y-auto p-4 space-y-1">
            <a href="#dashboard" class="nav-link flex items-center space-x-3 px-3 py-2.5 rounded-lg text-sm" data-section="dashboard">
                <i data-lucide="layout-dashboard" class="lucide w-5 h-5"></i>
                <span>Dashboard</span>
            </a>
            <a href="#reports" class="nav-link flex items-center space-x-3 px-3 py-2.5 rounded-lg text-sm" data-section="reports">
                <i data-lucide="bar-chart-3" class="lucide w-5 h-5"></i>
                <span>Reports</span>
            </a>
            <a href="#settings" class="nav-link flex items-center space-x-3 px-3 py-2.5 rounded-lg text-sm" data-section="settings">
                <i data-lucide="settings" class="lucide w-5 h-5"></i>
                <span>Settings</span>
            </a>
        </nav>

        <div class="p-4 border-t text-xs text-gray-500 space-y-1">
            <div id="connection-status" class="flex items-center space-x-1.5">
                <span class="w-2 h-2 rounded-full bg-red-500 inline-block animate-pulse" id="status-indicator"></span>
                <span id="status-text">Connecting...</span>
            </div>
            <div id="student-count">Students: 0</div>
        </div>
    </aside>

    <div id="sidebar-backdrop" class="md:hidden"></div>

    <main class="flex-1 flex flex-col overflow-hidden">
        <header class="bg-white shadow-sm p-4 flex items-center justify-between h-16">
            <div class="flex items-center">
                 <button id="menu-btn" class="md:hidden btn-icon mr-2">
                     <i data-lucide="menu" class="lucide h-5 w-5"></i>
                 </button>
                 <h2 id="section-title" class="text-xl font-semibold text-gray-800">Dashboard</h2>
            </div>
            <div>
                </div>
        </header>

        <div class="flex-1 overflow-y-auto p-6 space-y-6">
            <section id="dashboard-section" class="section-content">
                <div class="mb-4 flex flex-wrap gap-2">
                     </div>

                <div id="student-grid" class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5 gap-4">
                    </div>
                <div id="no-students-message" class="text-center text-gray-500 py-16 hidden">
                    <i data-lucide="users" class="lucide w-16 h-16 mx-auto mb-4 text-gray-400"></i>
                    <p class="text-lg font-medium">No students connected yet.</p>
                    <p class="text-sm mt-1">Ensure the Saber extension is active on student devices.</p>
                </div>
            </section>

            <section id="reports-section" class="section-content hidden">
                <div class="bg-white p-6 rounded-lg shadow space-y-6">
                    <h3 class="text-xl font-semibold text-gray-800 border-b pb-3">Student Activity Reports</h3>

                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 items-end">
                        <div>
                            <label for="report-student-select" class="block text-sm font-medium text-gray-700 mb-1">Select Student</label>
                            <select id="report-student-select" class="input-field">
                                <option value="">-- Select a student --</option>
                                </select>
                        </div>
                        <div class="md:col-span-1">
                            <button id="clear-history-btn" class="w-full btn btn-danger">
                                <i data-lucide="trash-2" class="lucide w-4 h-4 mr-2"></i> Clear Selected Student History
                            </button>
                        </div>

                    </div>

                    <div id="report-content" class="hidden space-y-6 pt-4 border-t">
                        <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
                             <div class="bg-gray-50 p-4 rounded-lg border">
                                <h4 class="text-lg font-medium text-gray-700 mb-3 text-center">Top Visited Domains</h4>
                                <div class="relative h-64 md:h-80">
                                    <canvas id="domain-chart"></canvas>
                                </div>
                                <p id="chart-no-data" class="text-center text-gray-500 text-sm mt-4 hidden">No browsing data available for charts.</p>
                            </div>
                            <div class="bg-gray-50 p-4 rounded-lg border flex items-center justify-center">
                                <p class="text-gray-500 italic">More stats coming soon...</p>
                            </div>
                        </div>

                        <div>
                            <h4 class="text-lg font-medium text-gray-700 mb-3">Browsing History Details</h4>
                            <div class="overflow-x-auto border rounded-lg max-h-96">
                                <table class="min-w-full divide-y divide-gray-200">
                                    <thead class="bg-gray-50 sticky top-0">
                                        <tr>
                                            <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Timestamp</th>
                                            <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Domain</th>
                                            <th scope="col" class="px-4 py-2 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Title / URL</th>
                                        </tr>
                                    </thead>
                                    <tbody id="history-table-body" class="bg-white divide-y divide-gray-200">
                                        <tr><td colspan="3" class="text-center p-4 text-sm text-gray-500" id="history-no-data">No history recorded for this student.</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                     <div id="report-prompt" class="text-center text-gray-500 py-8">
                         <i data-lucide="info" class="lucide w-10 h-10 mx-auto mb-3 text-gray-400"></i>
                         <p>Select a student to view their activity report.</p>
                         <p class="text-xs mt-1">(History is stored locally in your browser)</p>
                     </div>
                </div>
            </section>

            <section id="settings-section" class="section-content hidden">
                 <div class="bg-white p-6 rounded-lg shadow space-y-6 max-w-3xl mx-auto">
                     <h3 class="text-xl font-semibold text-gray-800 border-b pb-3">Settings</h3>
                    <div>
                        <label for="screenshot-interval" class="block text-sm font-medium text-gray-700">Screenshot Interval (ms)</label>
                        <div class="mt-1 flex items-center space-x-2">
                            <input type="number" id="screenshot-interval" name="screenshot-interval" value="5000" min="1000" step="500" class="input-field max-w-xs">
                            <button id="save-screenshot-interval" class="btn btn-primary">Update for All</button>
                        </div>
                        <p class="mt-2 text-xs text-gray-500">Set how often student screenshots are captured (min 1000ms). Lower values increase network load. Applied to all currently connected students.</p>
                    </div>

                    <hr>

                    <div>
                        <label for="blocklist" class="block text-sm font-medium text-gray-700">Blocked Websites (Patterns)</label>
                        <textarea id="blocklist" name="blocklist" rows="5" class="input-field mt-1" placeholder="*://*.coolmathgames.com/*&#10;*://*.youtube.com/*&#10;*://some.specific.site/path/*"></textarea>
                        <div class="mt-2 flex items-center justify-between">
                             <button id="save-blocklist" class="btn btn-primary">Update Blocklist for All</button>
                             <p class="text-xs text-gray-500 text-right">Enter URL patterns (one per line). Use * as wildcard.<br>Applied to all currently connected students.</p>
                        </div>

                    </div>
                 </div>
            </section>
        </div>
    </main>

    <template id="student-card-template">
        <div class="student-card bg-white rounded-lg shadow overflow-hidden cursor-pointer flex flex-col border border-transparent hover:border-blue-300 transition-colors duration-150" data-client-id="">
            <div class="screenshot-container relative bg-gray-200 aspect-video rounded-t-lg">
                <img class="student-screenshot-img" src="https://placehold.co/320x180/e2e8f0/64748b?text=Connecting..." alt="Student Screen Preview" onerror="this.src='https://placehold.co/320x180/e2e8f0/64748b?text=Error'; this.classList.add('hidden'); this.nextElementSibling.classList.remove('hidden');">
                <div class="screenshot-placeholder hidden"> <i data-lucide="monitor-off" class="lucide w-8 h-8 mb-1"></i>
                    <span>No Screenshot</span>
                </div>
            </div>
            <div class="p-3 border-t border-gray-200 flex-grow">
                <p class="student-email font-semibold text-sm truncate" title="student@example.com">student@example.com</p>
                <div class="flex items-center text-xs text-gray-500 mt-1">
                    <img class="student-favicon w-4 h-4 mr-1.5 flex-shrink-0" src="https://placehold.co/16x16/cccccc/999999?text=?" alt="favicon" onerror="this.src='https://placehold.co/16x16/cccccc/999999?text=?'">
                    <span class="student-active-tab-title truncate" title="Loading tab info...">Loading tab info...</span>
                </div>
            </div>
             <div class="p-2 bg-gray-50 border-t flex justify-end space-x-1">
                 <button class="action-btn lock-btn btn-icon-sm text-red-500 hover:bg-red-100" title="Lock Screen">
                     <i data-lucide="lock" class="lucide w-4 h-4"></i>
                 </button>
                 <button class="action-btn message-btn btn-icon-sm text-blue-500 hover:bg-blue-100" title="Send Message">
                     <i data-lucide="message-square" class="lucide w-4 h-4"></i>
                 </button>
                 <button class="action-btn close-tab-btn btn-icon-sm text-orange-500 hover:bg-orange-100" title="Close Active Tab">
                     <i data-lucide="x-circle" class="lucide w-4 h-4"></i>
                 </button>
             </div>
        </div>
    </template>

    <div id="student-modal" class="modal-backdrop hidden">
        <div class="modal"> <div class="flex justify-between items-center p-4 border-b">
                <h3 class="text-lg font-semibold text-gray-800 modal-student-email">Student Details</h3>
                <button id="close-modal-btn" class="btn-icon">
                    <i data-lucide="x" class="lucide h-5 w-5"></i>
                </button>
            </div>
            <div class="p-4 flex-1 overflow-y-auto grid grid-cols-1 lg:grid-cols-3 gap-4">
                <div class="lg:col-span-2">
                    <h4 class="text-sm font-medium mb-2 text-gray-600 uppercase tracking-wider">Live Screen</h4>
                    <div class="modal-screenshot-container bg-gray-200 rounded-md overflow-hidden aspect-video relative border">
                        <img id="modal-screenshot-img" class="w-full h-full object-contain bg-gray-500" src="https://placehold.co/640x360/e2e8f0/64748b?text=Loading..." alt="Large Student Screen">
                        <div id="modal-screenshot-placeholder" class="absolute inset-0 screenshot-placeholder hidden bg-gray-200">
                            <i data-lucide="monitor-off" class="lucide w-12 h-12 mb-2"></i>
                            <span>No Screenshot Available</span>
                        </div>
                    </div>
                </div>
                <div class="lg:col-span-1 flex flex-col">
                    <div class="flex-1 flex flex-col mb-4 min-h-[150px]">
                         <h4 class="text-sm font-medium mb-2 text-gray-600 uppercase tracking-wider">Open Tabs (<span id="modal-tab-count">0</span>)</h4>
                         <div id="modal-tab-list" class="flex-1 overflow-y-auto border rounded p-2 space-y-1 bg-gray-50 min-h-[100px] max-h-60 lg:max-h-none">
                             <p class="text-xs text-gray-400 text-center py-4">No tab information received yet.</p>
                             </div>
                    </div>
                    <div>
                        <h4 class="text-sm font-medium mb-2 text-gray-600 uppercase tracking-wider">Actions</h4>
                        <div class="space-y-2">
                            <div class="grid grid-cols-2 gap-2">
                                <button id="modal-lock-btn" class="btn btn-danger text-sm w-full">
                                    <i data-lucide="lock" class="lucide w-4 h-4 mr-1.5"></i> Lock
                                </button>
                                <button id="modal-unlock-btn" class="btn btn-success text-sm w-full">
                                    <i data-lucide="unlock" class="lucide w-4 h-4 mr-1.5"></i> Unlock
                                </button>
                            </div>
                            <div class="flex space-x-2">
                                <input type="url" id="modal-open-url-input" placeholder="https://example.com" class="input-field text-sm flex-grow">
                                <button id="modal-open-tab-btn" class="btn btn-primary flex-shrink-0" title="Open New Tab">
                                    <i data-lucide="external-link" class="lucide w-4 h-4"></i>
                                </button>
                            </div>
                            <div class="flex space-x-2">
                                <input type="text" id="modal-announce-input" placeholder="Send announcement..." class="input-field text-sm flex-grow">
                                <button id="modal-announce-btn" class="btn btn-warning flex-shrink-0" title="Send Announcement">
                                    <i data-lucide="megaphone" class="lucide w-4 h-4"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div id="toast-container" class="fixed bottom-5 right-5 z-[100] space-y-2 w-80">
        <template id="toast-template">
            <div class="toast bg-gray-800 text-white p-3 rounded-lg shadow-md text-sm flex items-center space-x-3 transition-all duration-300 ease-out opacity-0 translate-x-full" role="alert">
                <span class="toast-icon flex-shrink-0"></span>
                <span class="toast-message flex-grow">Message here</span>
                <button class="toast-close ml-auto text-gray-300 hover:text-white flex-shrink-0">
                    <i data-lucide="x" class="lucide w-4 h-4"></i>
                </button>
            </div>
        </template>
    </div>


    <script>
        // --- Constants and State ---
        const AppConfig = {
            WS_URL: "wss://saber-i394.onrender.com", // WebSocket server URL
            RECONNECT_DELAY: 5000, // 5 seconds
            PING_INTERVAL: 30000, // 30 seconds
            HISTORY_STORAGE_KEY: 'saberStudentHistory_v1', // Key for localStorage
            MAX_HISTORY_PER_STUDENT: 200 // Limit history entries to prevent excessive storage use
        };

        const AppState = {
            ws: null,
            pingIntervalId: null,
            reconnectTimeoutId: null,
            students: new Map(), // Map<clientId, StudentData>
            studentHistory: new Map(), // Map<clientId, Array<HistoryEntry>>
            currentModalClientId: null,
            activeSection: 'dashboard',
            domainChartInstance: null,
            isLoadingHistory: false
        };

        // --- DOM Element Cache ---
        // Cache frequently accessed DOM elements for performance
        const DOMElements = {
            statusIndicator: document.getElementById('status-indicator'),
            statusText: document.getElementById('status-text'),
            studentCountElement: document.getElementById('student-count'),
            studentGrid: document.getElementById('student-grid'),
            studentCardTemplate: document.getElementById('student-card-template'),
            noStudentsMessage: document.getElementById('no-students-message'),
            studentModal: document.getElementById('student-modal'),
            closeModalBtn: document.getElementById('close-modal-btn'),
            modalStudentEmail: document.querySelector('#student-modal .modal-student-email'),
            modalScreenshotImg: document.getElementById('modal-screenshot-img'),
            modalScreenshotPlaceholder: document.getElementById('modal-screenshot-placeholder'),
            modalTabList: document.getElementById('modal-tab-list'),
            modalTabCount: document.getElementById('modal-tab-count'),
            modalLockBtn: document.getElementById('modal-lock-btn'),
            modalUnlockBtn: document.getElementById('modal-unlock-btn'),
            modalOpenTabBtn: document.getElementById('modal-open-tab-btn'),
            modalOpenUrlInput: document.getElementById('modal-open-url-input'),
            modalAnnounceBtn: document.getElementById('modal-announce-btn'),
            modalAnnounceInput: document.getElementById('modal-announce-input'),
            sectionTitle: document.getElementById('section-title'),
            navLinks: document.querySelectorAll('.nav-link'),
            sections: document.querySelectorAll('.section-content'),
            menuBtn: document.getElementById('menu-btn'),
            sidebar: document.getElementById('sidebar'),
            closeSidebarBtn: document.getElementById('close-sidebar-btn'),
            sidebarBackdrop: document.getElementById('sidebar-backdrop'),
            toastContainer: document.getElementById('toast-container'),
            toastTemplate: document.getElementById('toast-template'),
            settingsScreenshotIntervalInput: document.getElementById('screenshot-interval'),
            settingsSaveScreenshotIntervalBtn: document.getElementById('save-screenshot-interval'),
            settingsBlocklistTextarea: document.getElementById('blocklist'),
            settingsSaveBlocklistBtn: document.getElementById('save-blocklist'),
            // Reports Section Elements
            reportStudentSelect: document.getElementById('report-student-select'),
            reportContent: document.getElementById('report-content'),
            reportPrompt: document.getElementById('report-prompt'),
            domainChartCanvas: document.getElementById('domain-chart'),
            chartNoData: document.getElementById('chart-no-data'),
            historyTableBody: document.getElementById('history-table-body'),
            historyNoData: document.getElementById('history-no-data'),
            clearHistoryBtn: document.getElementById('clear-history-btn'),
        };

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            console.log("DOM Loaded. Initializing Saber Dashboard...");
            initApp();
        });

        /**
         * Initializes the application: loads history, sets up UI, connects WebSocket.
         */
        function initApp() {
            loadHistoryFromStorage(); // Load history first
            initUI();
            initWebSocket();
            lucide.createIcons(); // Initial icon rendering
        }

        /**
         * Initializes UI elements, event listeners, and SortableJS.
         */
        function initUI() {
            // Initial UI State
            updateStudentCount();
            checkEmptyGrid();
            updateReportStudentDropdown(); // Populate dropdown initially (might be empty)

            // Event Listeners
            setupEventListeners();

            // Initialize SortableJS for drag & drop
            if (DOMElements.studentGrid) {
                 new Sortable(DOMElements.studentGrid, {
                    animation: 150,
                    ghostClass: 'sortable-ghost',
                    handle: '.student-card', // Allows dragging the whole card
                    filter: '.action-btn', // Prevent starting drag from buttons
                    onEnd: (evt) => {
                        // Optional: Handle reordering logic if persistence is needed
                        console.log('Item reordered:', evt.oldIndex, '->', evt.newIndex);
                    },
                });
            } else {
                console.error("Student grid element not found for SortableJS.");
            }

            // Set initial section based on hash or default to dashboard
            const hash = window.location.hash.substring(1);
            const validSections = Array.from(DOMElements.navLinks).map(link => link.dataset.section);
            const initialSection = validSections.includes(hash) ? hash : 'dashboard';
            setActiveSection(initialSection);
        }

        /**
         * Sets up all necessary event listeners for the application.
         */
        function setupEventListeners() {
            // Modal listeners
            DOMElements.closeModalBtn?.addEventListener('click', closeStudentModal);
            DOMElements.studentModal?.addEventListener('click', (event) => {
                if (event.target === DOMElements.studentModal) closeStudentModal();
            });
            DOMElements.modalLockBtn?.addEventListener('click', handleModalAction('lock_screen', 'Sent lock command'));
            DOMElements.modalUnlockBtn?.addEventListener('click', handleModalAction('unlock_screen', 'Sent unlock command'));
            DOMElements.modalOpenTabBtn?.addEventListener('click', handleModalOpenTab);
            DOMElements.modalAnnounceBtn?.addEventListener('click', handleModalAnnounce);

            // Navigation listeners
            DOMElements.navLinks.forEach(link => {
                link.addEventListener('click', handleNavLinkClick);
            });

            // Mobile Sidebar listeners
            DOMElements.menuBtn?.addEventListener('click', toggleMobileSidebar);
            DOMElements.closeSidebarBtn?.addEventListener('click', toggleMobileSidebar);
            DOMElements.sidebarBackdrop?.addEventListener('click', toggleMobileSidebar);

            // Settings listeners
            DOMElements.settingsSaveScreenshotIntervalBtn?.addEventListener('click', handleSaveScreenshotInterval);
            DOMElements.settingsSaveBlocklistBtn?.addEventListener('click', handleSaveBlocklist);

            // Reports listeners
            DOMElements.reportStudentSelect?.addEventListener('change', handleReportStudentChange);
            DOMElements.clearHistoryBtn?.addEventListener('click', handleClearHistory);
        }

        // --- WebSocket Management ---

        /**
         * Initiates WebSocket connection.
         */
        function initWebSocket() {
            connectWebSocket();
        }

        /**
         * Establishes WebSocket connection and sets up handlers.
         */
        function connectWebSocket() {
            if (AppState.ws && (AppState.ws.readyState === WebSocket.OPEN || AppState.ws.readyState === WebSocket.CONNECTING)) {
                console.log("WebSocket connection attempt already in progress or open.");
                return;
            }

            clearTimeout(AppState.reconnectTimeoutId);
            console.log(`Attempting to connect to ${AppConfig.WS_URL}...`);
            updateStatus('Connecting...', 'orange', true); // Add pulse on connecting

            try {
                 AppState.ws = new WebSocket(AppConfig.WS_URL);

                 AppState.ws.onopen = () => {
                     console.log("WebSocket connection established.");
                     updateStatus('Connected', 'green');
                     sendMessage({ type: 'teacher_connect' });
                     startPing();
                 };

                 AppState.ws.onmessage = (event) => {
                     try {
                         const message = JSON.parse(event.data);
                         handleWebSocketMessage(message);
                     } catch (error) {
                         console.error("Error parsing WebSocket message:", error, event.data);
                     }
                 };

                 AppState.ws.onerror = (error) => {
                     console.error("WebSocket error:", error);
                     // onclose will handle reconnection attempt
                 };

                 AppState.ws.onclose = (event) => {
                     console.log(`WebSocket connection closed. Code: ${event.code}, Reason: ${event.reason}`);
                     AppState.ws = null;
                     stopPing();
                     updateStatus('Disconnected', 'red', true); // Add pulse on disconnected
                     scheduleReconnect();
                 };
            } catch (error) {
                console.error("Failed to create WebSocket:", error);
                updateStatus('Connection Failed', 'red');
                scheduleReconnect(); // Still try to reconnect even if initial creation failed
            }
        }

        /**
         * Sends a message payload through the WebSocket.
         * @param {object} payload - The message object to send.
         */
        function sendMessage(payload) {
            if (AppState.ws && AppState.ws.readyState === WebSocket.OPEN) {
                try {
                    // console.debug("Sending WS:", payload); // Uncomment for detailed debugging
                    AppState.ws.send(JSON.stringify(payload));
                } catch (error) {
                    console.error("Error sending WebSocket message:", error);
                }
            } else {
                console.warn("WebSocket not open. Message not sent:", payload);
                showToast("Connection error. Cannot send command.", "error");
            }
        }

        /**
         * Schedules a WebSocket reconnection attempt.
         */
        function scheduleReconnect() {
            clearTimeout(AppState.reconnectTimeoutId);
            stopPing();
            console.log(`Scheduling reconnect in ${AppConfig.RECONNECT_DELAY / 1000}s...`);
            AppState.reconnectTimeoutId = setTimeout(connectWebSocket, AppConfig.RECONNECT_DELAY);
        }

        /**
         * Starts the periodic ping mechanism.
         */
        function startPing() {
            stopPing();
            AppState.pingIntervalId = setInterval(() => {
                sendMessage({ type: 'ping' });
            }, AppConfig.PING_INTERVAL);
            // console.debug("Ping interval started.");
        }

        /**
         * Stops the periodic ping mechanism.
         */
        function stopPing() {
            clearInterval(AppState.pingIntervalId);
            AppState.pingIntervalId = null;
            // console.debug("Ping interval stopped.");
        }

        // --- WebSocket Message Handling ---

        /**
         * Routes incoming WebSocket messages to appropriate handlers.
         * @param {object} message - The parsed message object.
         */
        function handleWebSocketMessage(message) {
            const { type, data } = message;
            // console.debug(`Handling WS Message: ${type}`, data); // Uncomment for detailed debugging

            switch (type) {
                case 'pong': break; // Server acknowledged ping
                case 'server_ack': console.log("Server Ack:", data?.message); break;
                case 'error': handleServerError(data); break;
                case 'initial_student_list': handleInitialStudentList(data); break;
                case 'student_connected': handleStudentConnected(data); break;
                case 'student_disconnected': handleStudentDisconnected(data); break;
                // Tab Events
                case 'student_tabs_update':
                case 'student_tab_created':
                case 'student_tab_updated':
                case 'student_tab_removed':
                case 'student_tab_activated': // Assuming an activation event might exist
                    handleStudentTabUpdate(data.clientId, type, data.payload);
                    break;
                // Screenshot Events
                case 'student_screenshot':
                    handleStudentScreenshot(data.clientId, data.payload.imageData, data.payload.tabId);
                    break;
                case 'student_screenshot_error':
                case 'student_screenshot_skipped':
                     handleStudentScreenshot(data.clientId, null, data.payload?.tabId, type);
                     break;
                // Command Feedback
                case 'command_failed': handleCommandFailed(data); break;
                default:
                    console.warn("Received unhandled message type:", type, data);
            }
        }

        function handleServerError(data) {
            console.error("Server Error:", data?.message);
            showToast(`Server Error: ${data?.message || 'Unknown error'}`, "error");
        }

        function handleInitialStudentList(data) {
            console.log("Received initial student list:", data);
            clearStudentGrid();
            AppState.students.clear();
            if (Array.isArray(data)) {
                data.forEach(studentData => addStudent(studentData.clientId, studentData.email));
            }
            updateStudentCount();
            updateReportStudentDropdown();
            checkEmptyGrid();
        }

        function handleStudentConnected(data) {
             console.log("Student connected:", data);
             addStudent(data.clientId, data.email);
             updateStudentCount();
             updateReportStudentDropdown();
             checkEmptyGrid();
             showToast(`${data.email || data.clientId} connected.`, "success");
        }

        function handleStudentDisconnected(data) {
             console.log("Student disconnected:", data);
             const disconnectedStudentEmail = AppState.students.get(data.clientId)?.email;
             removeStudent(data.clientId);
             updateStudentCount();
             updateReportStudentDropdown();
             checkEmptyGrid();
             if (AppState.currentModalClientId === data.clientId) {
                 closeStudentModal();
             }
             showToast(`Student ${disconnectedStudentEmail || data.clientId} disconnected.`, "warning");
        }

         function handleStudentTabUpdate(clientId, type, payload) {
             const student = AppState.students.get(clientId);
             if (!student) return;

             student.lastSeen = Date.now();
             let previousActiveTab = student.activeTab; // Store previous active tab for history logging

             // Update local student.currentTabs based on event type
             switch (type) {
                 case 'student_tabs_update': // Payload is the complete tabs object
                     student.currentTabs = payload || {};
                     break;
                 case 'student_tab_created':
                 case 'student_tab_updated':
                 case 'student_tab_activated': // Treat activation like an update for rendering
                     if (payload && payload.id) {
                         student.currentTabs[payload.id] = { ...(student.currentTabs[payload.id] || {}), ...payload };
                     }
                     break;
                 case 'student_tab_removed':
                     if (payload && payload.id) {
                         delete student.currentTabs[payload.id];
                     }
                     break;
             }

             // Identify the *new* active tab after the update
             let newActiveTab = null;
             for (const tabId in student.currentTabs) {
                 if (student.currentTabs[tabId]?.active) {
                     newActiveTab = student.currentTabs[tabId];
                     break;
                 }
             }
             student.activeTab = newActiveTab;

             // --- History Logging ---
             // Log history when the active tab changes URL or a new tab becomes active
             if (newActiveTab && (!previousActiveTab || previousActiveTab.id !== newActiveTab.id || previousActiveTab.url !== newActiveTab.url)) {
                 if (newActiveTab.url && (newActiveTab.url.startsWith('http:') || newActiveTab.url.startsWith('https:'))) {
                     logStudentHistory(clientId, newActiveTab.url, newActiveTab.title);
                 }
             }

             // Re-render UI parts
             renderStudentCardTabInfo(clientId);
             if (AppState.currentModalClientId === clientId) {
                 populateModalTabs(student.currentTabs);
             }
         }

         function handleStudentScreenshot(clientId, imageDataUrl, tabId, status = 'ok') {
             const student = AppState.students.get(clientId);
             if (!student || !student.element) return;

             student.lastSeen = Date.now();
             const imgElement = student.element.querySelector('.student-screenshot-img');
             const placeholderElement = student.element.querySelector('.screenshot-placeholder');
             if (!imgElement || !placeholderElement) return; // Guard against missing elements

             let placeholderIconName = 'monitor-off';
             let placeholderText = 'No Screenshot';

             if (imageDataUrl && status === 'ok') {
                 student.screenshotUrl = imageDataUrl;
                 imgElement.src = imageDataUrl;
                 imgElement.classList.remove('hidden');
                 placeholderElement.classList.add('hidden');
             } else {
                 student.screenshotUrl = null;
                 imgElement.classList.add('hidden');
                 placeholderElement.classList.remove('hidden');

                 if (status === 'student_screenshot_error') {
                     placeholderIconName = 'alert-circle';
                     placeholderText = 'Error Loading';
                 } else if (status === 'student_screenshot_skipped') {
                     placeholderIconName = 'eye-off';
                     placeholderText = 'Capture Skipped';
                 }
                 // Update placeholder content
                 const placeholderIcon = placeholderElement.querySelector('i');
                 const placeholderSpan = placeholderElement.querySelector('span');
                 if (placeholderIcon) placeholderIcon.dataset.lucide = placeholderIconName;
                 if (placeholderSpan) placeholderSpan.textContent = placeholderText;
                 lucide.createIcons(); // Re-render icon if changed
             }

             // Update modal if it's open for this student
             if (AppState.currentModalClientId === clientId) {
                 if (student.screenshotUrl) {
                     DOMElements.modalScreenshotImg.src = student.screenshotUrl;
                     DOMElements.modalScreenshotImg.classList.remove('hidden');
                     DOMElements.modalScreenshotPlaceholder.classList.add('hidden');
                 } else {
                     DOMElements.modalScreenshotImg.classList.add('hidden');
                     DOMElements.modalScreenshotPlaceholder.classList.remove('hidden');
                     // Update modal placeholder content too
                     const modalPlaceholderIcon = DOMElements.modalScreenshotPlaceholder.querySelector('i');
                     const modalPlaceholderSpan = DOMElements.modalScreenshotPlaceholder.querySelector('span');
                     if (modalPlaceholderIcon) modalPlaceholderIcon.dataset.lucide = placeholderIconName;
                     if (modalPlaceholderSpan) modalPlaceholderSpan.textContent = placeholderText;
                     lucide.createIcons();
                 }
             }
         }

        function handleCommandFailed(data) {
             console.error("Command failed:", data);
             const studentEmail = AppState.students.get(data.targetClientId)?.email;
             showToast(`Command failed for ${studentEmail || data.targetClientId}: ${data.reason}`, "error");
        }

        // --- Student Data & UI Updates ---

        /**
         * Updates the connection status indicator and text.
         * @param {string} text - The status text.
         * @param {string} color - Tailwind color name (e.g., 'green', 'red', 'orange').
         * @param {boolean} [pulse=false] - Whether to add a pulsing animation.
         */
        function updateStatus(text, color, pulse = false) {
            if (!DOMElements.statusText || !DOMElements.statusIndicator) return;
            DOMElements.statusText.textContent = text;
            DOMElements.statusIndicator.className = `w-2 h-2 rounded-full bg-${color}-500 inline-block ${pulse ? 'animate-pulse' : ''}`;
        }

        /**
         * Updates the student count display.
         */
        function updateStudentCount() {
             if (!DOMElements.studentCountElement) return;
             DOMElements.studentCountElement.textContent = `Students: ${AppState.students.size}`;
        }

        /**
         * Clears all student cards from the grid.
         */
        function clearStudentGrid() {
            if (DOMElements.studentGrid) DOMElements.studentGrid.innerHTML = '';
        }

        /**
         * Shows or hides the 'no students' message based on the student count.
         */
        function checkEmptyGrid() {
             if (!DOMElements.noStudentsMessage || !DOMElements.studentGrid) return;
             const hasStudents = AppState.students.size > 0;
             DOMElements.noStudentsMessage.classList.toggle('hidden', hasStudents);
             DOMElements.studentGrid.classList.toggle('hidden', !hasStudents);
        }

        /**
         * Adds a new student card to the grid or updates an existing one.
         * @param {string} clientId - The unique ID of the student.
         * @param {string} email - The student's email address.
         */
        function addStudent(clientId, email) {
            if (AppState.students.has(clientId)) {
                console.warn(`Student ${clientId} already exists. Updating email.`);
                const existingStudent = AppState.students.get(clientId);
                existingStudent.email = email;
                const emailElement = existingStudent.element?.querySelector('.student-email');
                if (emailElement) {
                    emailElement.textContent = email || clientId;
                    emailElement.title = email || clientId;
                }
                return; // Don't add duplicate card
            }

            if (!DOMElements.studentCardTemplate || !DOMElements.studentGrid) return;

            const templateClone = DOMElements.studentCardTemplate.content.cloneNode(true);
            const studentCard = templateClone.querySelector('.student-card');
            if (!studentCard) return;

            studentCard.dataset.clientId = clientId;

            const emailElement = studentCard.querySelector('.student-email');
            if (emailElement) {
                emailElement.textContent = email || clientId;
                emailElement.title = email || clientId;
            }

            // Add event listeners for the card itself and internal buttons
            studentCard.addEventListener('click', (event) => {
                if (!event.target.closest('.action-btn')) { // Don't open modal if a button was clicked
                    openStudentModal(clientId);
                }
            });

            // Action buttons within the card
            studentCard.querySelector('.lock-btn')?.addEventListener('click', (e) => {
                e.stopPropagation();
                sendTeacherCommand(clientId, 'lock_screen');
                showToast(`Sent lock command to ${email || clientId}`, 'info');
            });
            studentCard.querySelector('.message-btn')?.addEventListener('click', (e) => {
                 e.stopPropagation();
                 const message = prompt(`Enter message/announcement for ${email || clientId}:`);
                 if (message) {
                     sendTeacherCommand(clientId, 'send_announcement', { message: message });
                     showToast(`Sent announcement to ${email || clientId}`, 'info');
                 }
            });
            studentCard.querySelector('.close-tab-btn')?.addEventListener('click', (e) => {
                 e.stopPropagation();
                 const studentData = AppState.students.get(clientId);
                 const activeTab = studentData?.activeTab;
                 if (activeTab?.id) {
                     if (confirm(`Close tab "${activeTab.title || activeTab.url}" for ${email || clientId}?`)) {
                         sendTeacherCommand(clientId, 'close_tab', { tabId: activeTab.id });
                         showToast(`Sent close tab command for "${activeTab.title || 'active tab'}" to ${email || clientId}`, 'info');
                     }
                 } else {
                     showToast(`Cannot determine active tab for ${email || clientId} to close.`, 'warning');
                 }
            });

            DOMElements.studentGrid.appendChild(studentCard);
            AppState.students.set(clientId, {
                clientId: clientId,
                email: email,
                element: studentCard,
                currentTabs: {},
                lastSeen: Date.now(),
                activeTab: null,
                screenshotUrl: null
            });

            checkEmptyGrid();
            lucide.createIcons(); // Render icons on the new card
        }

        /**
         * Removes a student card from the grid and the state.
         * @param {string} clientId - The ID of the student to remove.
         */
        function removeStudent(clientId) {
            const student = AppState.students.get(clientId);
            student?.element?.remove(); // Remove card from DOM
            AppState.students.delete(clientId); // Remove from state map
            // Note: History is kept unless explicitly cleared
            checkEmptyGrid();
        }

        /**
         * Updates the active tab information displayed on a student's card.
         * @param {string} clientId - The ID of the student.
         */
        function renderStudentCardTabInfo(clientId) {
            const student = AppState.students.get(clientId);
            if (!student || !student.element) return;

            const cardFavicon = student.element.querySelector('.student-favicon');
            const cardTitle = student.element.querySelector('.student-active-tab-title');
            if (!cardFavicon || !cardTitle) return;

            const activeTab = student.activeTab; // Use the stored activeTab

            const defaultFavicon = 'https://placehold.co/16x16/cccccc/999999?text=?';
            cardFavicon.onerror = () => { cardFavicon.src = defaultFavicon; }; // Set onerror handler *before* setting src

            if (activeTab) {
                cardFavicon.src = activeTab.favIconUrl || defaultFavicon;
                cardFavicon.alt = activeTab.title || 'favicon';

                let titleText = 'Untitled';
                 try {
                     if (activeTab.title) {
                         titleText = activeTab.title;
                     } else if (activeTab.url && (activeTab.url.startsWith('http:') || activeTab.url.startsWith('https:'))) {
                         titleText = new URL(activeTab.url).hostname;
                     } else if (activeTab.url) {
                         titleText = activeTab.url.split(':')[0] + ' page'; // e.g., "chrome page"
                     }
                 } catch (e) {
                     titleText = 'Invalid URL';
                 }
                 cardTitle.textContent = titleText;
                 cardTitle.title = `${activeTab.title || 'No Title'}\n${activeTab.url || 'No URL'}`;
            } else {
                cardFavicon.src = defaultFavicon;
                cardFavicon.alt = 'favicon';
                cardTitle.textContent = 'No active tab';
                cardTitle.title = 'No active tab';
            }
        }

        // --- Modal Management ---

        /**
         * Opens the student detail modal for a specific client.
         * @param {string} clientId - The ID of the student.
         */
        function openStudentModal(clientId) {
            const student = AppState.students.get(clientId);
            if (!student || !DOMElements.studentModal) return;

            AppState.currentModalClientId = clientId;

            if (DOMElements.modalStudentEmail) {
                DOMElements.modalStudentEmail.textContent = student.email || clientId;
            }

            // Set initial screenshot
            handleStudentScreenshot(clientId, student.screenshotUrl); // Re-use logic to set modal screenshot/placeholder

            // Populate tab list
            populateModalTabs(student.currentTabs);

            // Show modal
            DOMElements.studentModal.classList.remove('hidden');
            DOMElements.studentModal.classList.add('flex'); // Use flex for centering
            lucide.createIcons(); // Ensure icons in modal are rendered
        }

        /**
         * Closes the student detail modal.
         */
        function closeStudentModal() {
            AppState.currentModalClientId = null;
            if (DOMElements.studentModal) {
                DOMElements.studentModal.classList.add('hidden');
                DOMElements.studentModal.classList.remove('flex');
            }
            // Clear inputs
            if (DOMElements.modalOpenUrlInput) DOMElements.modalOpenUrlInput.value = '';
            if (DOMElements.modalAnnounceInput) DOMElements.modalAnnounceInput.value = '';
        }

        /**
         * Populates the tab list within the student detail modal.
         * @param {object} tabsData - The student's current tab data object.
         */
        function populateModalTabs(tabsData) {
            if (!DOMElements.modalTabList || !DOMElements.modalTabCount) return;

            DOMElements.modalTabList.innerHTML = ''; // Clear previous tabs
            const tabIds = Object.keys(tabsData || {});
            DOMElements.modalTabCount.textContent = tabIds.length;

            if (tabIds.length === 0) {
                DOMElements.modalTabList.innerHTML = '<p class="text-xs text-gray-400 text-center py-4">No open tabs reported.</p>';
                return;
            }

            tabIds.forEach(tabId => {
                const tab = tabsData[tabId];
                if (!tab) return;

                const tabElement = document.createElement('div');
                tabElement.className = `flex items-center justify-between p-1.5 rounded text-xs ${tab.active ? 'bg-blue-100 font-medium' : 'bg-white'} hover:bg-gray-100`;

                const infoDiv = document.createElement('div');
                infoDiv.className = 'flex items-center space-x-1.5 overflow-hidden mr-2 flex-grow min-w-0'; // Allow shrinking

                const favicon = document.createElement('img');
                const defaultFavicon = 'https://placehold.co/16x16/cccccc/999999?text=?';
                favicon.onerror = () => { favicon.src = defaultFavicon; }; // Handle favicon errors
                favicon.src = tab.favIconUrl || defaultFavicon;
                favicon.alt = 'favicon';
                favicon.className = 'w-4 h-4 flex-shrink-0';

                const titleSpan = document.createElement('span');
                titleSpan.className = 'truncate';

                let hostname = 'Unknown Site';
                let titleText = 'Untitled';
                try {
                    if (tab.url && (tab.url.startsWith('http:') || tab.url.startsWith('https:'))) {
                        hostname = new URL(tab.url).hostname;
                    } else if (tab.url) {
                        hostname = tab.url.split(':')[0] + ' page';
                    }
                    titleText = tab.title || hostname;
                } catch (e) {
                    hostname = 'Invalid URL';
                    titleText = tab.title || hostname; // Still show title if URL is bad
                }
                titleSpan.textContent = titleText;
                titleSpan.title = `${tab.title || 'No Title'}\n${tab.url || 'No URL'}`;

                infoDiv.appendChild(favicon);
                infoDiv.appendChild(titleSpan);

                if (tab.audible) {
                    const soundIcon = document.createElement('i');
                    soundIcon.dataset.lucide = 'volume-2';
                    soundIcon.className = 'lucide w-3 h-3 text-gray-500 flex-shrink-0 ml-1';
                    infoDiv.appendChild(soundIcon);
                }

                const actionsDiv = document.createElement('div');
                actionsDiv.className = 'flex-shrink-0';

                const closeButton = document.createElement('button');
                closeButton.className = 'btn-icon-sm text-red-500 hover:bg-red-100';
                closeButton.title = 'Close Tab';
                closeButton.innerHTML = '<i data-lucide="x" class="lucide w-3 h-3"></i>';
                closeButton.onclick = () => {
                    if (AppState.currentModalClientId && confirm(`Close tab "${titleText}"?`)) {
                        sendTeacherCommand(AppState.currentModalClientId, 'close_tab', { tabId: tab.id });
                    }
                };
                actionsDiv.appendChild(closeButton);

                tabElement.appendChild(infoDiv);
                tabElement.appendChild(actionsDiv);
                DOMElements.modalTabList.appendChild(tabElement);
            });
            lucide.createIcons(); // Render any new icons
        }


        // --- Command Sending & Handling ---

        /**
         * Sends a structured command message via WebSocket.
         * @param {string} targetClientId - The ID of the target student.
         * @param {string} command - The command name (e.g., 'lock_screen').
         * @param {object} [data={}] - Additional data payload for the command.
         */
        function sendTeacherCommand(targetClientId, command, data = {}) {
            if (!targetClientId) {
                console.error("Cannot send command, targetClientId is missing.");
                showToast("Internal error: Missing target student ID.", "error");
                return;
            }
            const payload = {
                type: 'teacher_command', // DO NOT RENAME
                data: {
                    targetClientId: targetClientId,
                    command: command,
                    data: data // Specific payload for the command
                }
            };
            sendMessage(payload);
        }

        /**
         * Creates an event handler for modal action buttons.
         * @param {string} command - The command to send.
         * @param {string} toastMessage - The base message for the toast notification.
         * @returns {function} Event handler function.
         */
        function handleModalAction(command, toastMessage) {
            return () => {
                if (AppState.currentModalClientId) {
                    sendTeacherCommand(AppState.currentModalClientId, command);
                    const studentEmail = AppState.students.get(AppState.currentModalClientId)?.email;
                    showToast(`${toastMessage} to ${studentEmail || AppState.currentModalClientId}`, 'info');
                } else {
                     showToast("No student selected in modal.", "error");
                }
            };
        }

        /**
         * Handles the "Open Tab" action from the modal.
         */
        function handleModalOpenTab() {
            const url = DOMElements.modalOpenUrlInput?.value.trim();
            if (AppState.currentModalClientId && url) {
                if (!url.startsWith('http://') && !url.startsWith('https://')) {
                    showToast('Please enter a valid URL starting with http:// or https://', 'warning');
                    return;
                }
                sendTeacherCommand(AppState.currentModalClientId, 'open_tab', { url: url });
                const studentEmail = AppState.students.get(AppState.currentModalClientId)?.email;
                showToast(`Sent open tab command (${url}) to ${studentEmail || AppState.currentModalClientId}`, 'info');
                DOMElements.modalOpenUrlInput.value = '';
            } else if (!url) {
                showToast('Please enter a URL to open.', 'warning');
            }
        }

        /**
         * Handles the "Send Announcement" action from the modal.
         */
        function handleModalAnnounce() {
            const message = DOMElements.modalAnnounceInput?.value.trim();
            if (AppState.currentModalClientId && message) {
                sendTeacherCommand(AppState.currentModalClientId, 'send_announcement', { message: message, duration: 7000 });
                const studentEmail = AppState.students.get(AppState.currentModalClientId)?.email;
                showToast(`Sent announcement to ${studentEmail || AppState.currentModalClientId}`, 'info');
                DOMElements.modalAnnounceInput.value = '';
            } else if (!message) {
                showToast('Please enter an announcement message.', 'warning');
            }
        }

        // --- Navigation Handling ---

        /**
         * Handles clicks on navigation links.
         * @param {Event} e - The click event object.
         */
        function handleNavLinkClick(e) {
            e.preventDefault();
            const sectionId = e.currentTarget.dataset.section;
            if (sectionId) {
                setActiveSection(sectionId);
                window.location.hash = sectionId; // Update URL hash
            }
        }

        /**
         * Sets the currently active section in the UI.
         * @param {string} sectionId - The ID of the section to activate ('dashboard', 'reports', 'settings').
         */
        function setActiveSection(sectionId) {
            AppState.activeSection = sectionId;

            // Update Section Title
            const activeLink = document.querySelector(`.nav-link[data-section="${sectionId}"]`);
            if (activeLink && DOMElements.sectionTitle) {
                DOMElements.sectionTitle.textContent = activeLink.querySelector('span')?.textContent || 'Saber';
            }

            // Show/Hide Sections
            DOMElements.sections.forEach(section => {
                section.classList.toggle('hidden', section.id !== `${sectionId}-section`);
            });

            // Update Nav Link Styles
            DOMElements.navLinks.forEach(link => {
                link.classList.toggle('active', link.dataset.section === sectionId);
            });

            // Close mobile sidebar on navigation
            if (DOMElements.sidebar?.classList.contains('open')) {
                toggleMobileSidebar();
            }

            // If navigating to reports, ensure the student dropdown is up-to-date
            if (sectionId === 'reports') {
                updateReportStudentDropdown();
                // Reset report view if no student is selected
                if (!DOMElements.reportStudentSelect?.value) {
                     resetReportView();
                } else {
                    // Trigger display for the currently selected student if any
                    displayStudentReport(DOMElements.reportStudentSelect.value);
                }
            }
        }

        /**
         * Toggles the visibility of the mobile sidebar.
         */
        function toggleMobileSidebar() {
             if (DOMElements.sidebar && DOMElements.sidebarBackdrop) {
                 const isOpen = DOMElements.sidebar.classList.toggle('open');
                 DOMElements.sidebarBackdrop.style.display = isOpen ? 'block' : 'none';
             }
        }

        // --- Settings Handling ---

        /**
         * Handles saving the screenshot interval setting.
         */
        function handleSaveScreenshotInterval() {
            const inputElement = DOMElements.settingsScreenshotIntervalInput;
            if (!inputElement) return;

            const interval = parseInt(inputElement.value, 10);
            if (!isNaN(interval) && interval >= 1000) {
                if (AppState.students.size === 0) {
                    showToast('No students connected to send settings to.', 'warning');
                    return;
                }
                console.log(`Sending interval ${interval}ms to ${AppState.students.size} students.`);
                let count = 0;
                AppState.students.forEach((_, clientId) => {
                    sendTeacherCommand(clientId, 'set_screenshot_interval', { interval: interval });
                    count++;
                });
                showToast(`Sent interval update (${interval}ms) command to ${count} student(s).`, 'info');
            } else {
                showToast('Invalid interval. Must be a number >= 1000.', 'warning');
            }
        }

        /**
         * Handles saving the blocklist setting.
         */
        function handleSaveBlocklist() {
            const textareaElement = DOMElements.settingsBlocklistTextarea;
            if (!textareaElement) return;

            const blocklistText = textareaElement.value.trim();
            const blockedSites = blocklistText ? blocklistText.split('\n').map(s => s.trim()).filter(Boolean) : [];

            if (AppState.students.size === 0) {
                showToast('No students connected to send settings to.', 'warning');
                return;
            }
            console.log(`Sending blocklist update to ${AppState.students.size} students:`, blockedSites);
            let count = 0;
            AppState.students.forEach((_, clientId) => {
                sendTeacherCommand(clientId, 'update_blocklist', { blockedSites: blockedSites });
                count++;
            });
            showToast(`Sent blocklist update command to ${count} student(s).`, 'info');
        }

        // --- History Tracking & Reports ---

        /**
         * Logs a browsing history event for a student.
         * @param {string} clientId - The student's ID.
         * @param {string} url - The URL visited.
         * @param {string} title - The page title.
         */
        function logStudentHistory(clientId, url, title) {
             if (!clientId || !url) return;

             // Basic URL filtering (avoid internal pages, data URLs, etc.)
             if (!url.startsWith('http:') && !url.startsWith('https:')) {
                 // console.debug(`Skipping history log for non-HTTP(S) URL: ${url}`);
                 return;
             }

             let domain = 'Unknown';
             try {
                 domain = new URL(url).hostname;
             } catch (e) {
                 console.warn(`Could not parse domain from URL: ${url}`);
             }

             const newEntry = {
                 timestamp: Date.now(),
                 url: url,
                 title: title || 'No Title',
                 domain: domain
             };

             // console.debug(`Logging history for ${clientId}: ${domain}`);

             if (!AppState.studentHistory.has(clientId)) {
                 AppState.studentHistory.set(clientId, []);
             }

             const history = AppState.studentHistory.get(clientId);

             // Avoid logging consecutive identical URLs immediately
             const lastEntry = history[history.length - 1];
             if (lastEntry && lastEntry.url === newEntry.url) {
                 // console.debug("Skipping duplicate consecutive URL log.");
                 return;
             }


             history.push(newEntry);

             // Limit history size
             if (history.length > AppConfig.MAX_HISTORY_PER_STUDENT) {
                 history.shift(); // Remove the oldest entry
             }

             // Persist history (can be optimized to save less frequently)
             saveHistoryToStorage();

             // If the reports tab is active and this student is selected, update the view
             if (AppState.activeSection === 'reports' && DOMElements.reportStudentSelect?.value === clientId) {
                 // Debounce or delay this update if it causes performance issues
                 displayStudentReport(clientId);
             }
         }

        /**
         * Saves the current student history map to localStorage.
         */
        function saveHistoryToStorage() {
            try {
                // Convert Map to a serializable format (e.g., array of [key, value] pairs)
                const serializableHistory = Array.from(AppState.studentHistory.entries());
                localStorage.setItem(AppConfig.HISTORY_STORAGE_KEY, JSON.stringify(serializableHistory));
                // console.debug("History saved to localStorage.");
            } catch (error) {
                console.error("Error saving history to localStorage:", error);
                showToast("Could not save browsing history. Storage might be full.", "error");
            }
        }

        /**
         * Loads student history from localStorage.
         */
        function loadHistoryFromStorage() {
            try {
                const storedHistory = localStorage.getItem(AppConfig.HISTORY_STORAGE_KEY);
                if (storedHistory) {
                    // Parse and convert back to a Map
                    const parsedArray = JSON.parse(storedHistory);
                    AppState.studentHistory = new Map(parsedArray);
                    console.log(`Loaded history for ${AppState.studentHistory.size} students from localStorage.`);
                } else {
                    console.log("No history found in localStorage.");
                    AppState.studentHistory = new Map();
                }
            } catch (error) {
                console.error("Error loading history from localStorage:", error);
                AppState.studentHistory = new Map(); // Reset history on error
                showToast("Could not load browsing history.", "error");
            }
        }

        /**
         * Clears the history for the currently selected student in the report view.
         */
        function handleClearHistory() {
             const selectedClientId = DOMElements.reportStudentSelect?.value;
             if (!selectedClientId) {
                 showToast("Please select a student first.", "warning");
                 return;
             }

             const studentEmail = AppState.students.get(selectedClientId)?.email || selectedClientId;
             if (confirm(`Are you sure you want to clear all locally stored browsing history for ${studentEmail}? This cannot be undone.`)) {
                 if (AppState.studentHistory.has(selectedClientId)) {
                     AppState.studentHistory.delete(selectedClientId);
                     saveHistoryToStorage(); // Persist the change
                     displayStudentReport(selectedClientId); // Refresh the view
                     showToast(`Cleared history for ${studentEmail}.`, "success");
                 } else {
                     showToast(`No history found for ${studentEmail} to clear.`, "info");
                 }
             }
        }


        /**
         * Updates the student selection dropdown in the Reports section.
         */
        function updateReportStudentDropdown() {
            const select = DOMElements.reportStudentSelect;
            if (!select) return;

            const currentSelection = select.value; // Preserve selection if possible

            // Clear existing options (keep placeholder)
            while (select.options.length > 1) {
                select.remove(1);
            }

            // Sort students by email for dropdown consistency
            const sortedStudents = Array.from(AppState.students.values()).sort((a, b) => {
                const emailA = a.email || a.clientId;
                const emailB = b.email || b.clientId;
                return emailA.localeCompare(emailB);
            });

            // Add current students
            sortedStudents.forEach(student => {
                const option = document.createElement('option');
                option.value = student.clientId;
                option.textContent = student.email || student.clientId;
                select.appendChild(option);
            });

            // Restore previous selection if the student still exists
            if (AppState.students.has(currentSelection)) {
                select.value = currentSelection;
            } else {
                 select.value = ""; // Reset if previous selection is gone
                 resetReportView(); // Clear report view if selection is lost
            }
        }

        /**
         * Handles the change event for the student selection dropdown in Reports.
         */
        function handleReportStudentChange() {
            const selectedClientId = DOMElements.reportStudentSelect?.value;
            if (selectedClientId) {
                displayStudentReport(selectedClientId);
            } else {
                resetReportView();
            }
        }

        /**
         * Resets the report view to its initial state (prompt visible).
         */
        function resetReportView() {
            DOMElements.reportContent?.classList.add('hidden');
            DOMElements.reportPrompt?.classList.remove('hidden');
            // Optionally destroy the chart instance
            if (AppState.domainChartInstance) {
                AppState.domainChartInstance.destroy();
                AppState.domainChartInstance = null;
            }
        }

        /**
         * Displays the report (chart and table) for the selected student.
         * @param {string} clientId - The ID of the student whose report to display.
         */
        function displayStudentReport(clientId) {
            if (!clientId || AppState.isLoadingHistory) return; // Prevent concurrent loading
            AppState.isLoadingHistory = true;

            // Show content area, hide prompt
            DOMElements.reportContent?.classList.remove('hidden');
            DOMElements.reportPrompt?.classList.add('hidden');

            const history = AppState.studentHistory.get(clientId) || [];

            // Update Chart
            updateDomainChart(history);

            // Update Table
            updateHistoryTable(history);

            AppState.isLoadingHistory = false;
        }

        /**
         * Updates the domain distribution pie chart.
         * @param {Array<HistoryEntry>} history - The student's history array.
         */
        function updateDomainChart(history) {
            const canvas = DOMElements.domainChartCanvas;
            const noDataMsg = DOMElements.chartNoData;
            if (!canvas || !noDataMsg) return;

            // Destroy previous chart instance if it exists
            if (AppState.domainChartInstance) {
                AppState.domainChartInstance.destroy();
                AppState.domainChartInstance = null;
            }

            if (history.length === 0) {
                canvas.classList.add('hidden');
                noDataMsg.classList.remove('hidden');
                return;
            }

            canvas.classList.remove('hidden');
            noDataMsg.classList.add('hidden');

            // Aggregate domain counts
            const domainCounts = history.reduce((acc, entry) => {
                if (entry.domain && entry.domain !== 'Unknown') {
                    acc[entry.domain] = (acc[entry.domain] || 0) + 1;
                }
                return acc;
            }, {});

            // Sort domains by count and take top N (e.g., top 10)
            const sortedDomains = Object.entries(domainCounts)
                .sort(([, countA], [, countB]) => countB - countA);

            const topN = 10;
            const topDomains = sortedDomains.slice(0, topN);
            const otherCount = sortedDomains.slice(topN).reduce((sum, [, count]) => sum + count, 0);

            const labels = topDomains.map(([domain]) => domain);
            const data = topDomains.map(([, count]) => count);

            if (otherCount > 0) {
                labels.push('Other');
                data.push(otherCount);
            }

            // Define a color palette (add more colors if needed)
             const backgroundColors = [
                 '#3b82f6', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6',
                 '#ec4899', '#6366f1', '#14b8a6', '#f97316', '#d946ef',
                 '#6b7280' // Color for 'Other'
             ];
             const hoverBackgroundColors = backgroundColors.map(color => `${color}E6`); // Add slight transparency on hover


            AppState.domainChartInstance = new Chart(canvas, {
                type: 'doughnut', // Or 'pie'
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Visits',
                        data: data,
                        backgroundColor: backgroundColors.slice(0, data.length),
                        hoverBackgroundColor: hoverBackgroundColors.slice(0, data.length),
                        borderColor: '#ffffff', // White border for separation
                        borderWidth: 1,
                        hoverOffset: 8
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                boxWidth: 12,
                                padding: 15,
                                font: { size: 10 }
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed !== null) {
                                        label += context.parsed;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    animation: {
                         animateScale: true,
                         animateRotate: true
                    }
                }
            });
        }

        /**
         * Updates the browsing history table.
         * @param {Array<HistoryEntry>} history - The student's history array.
         */
        function updateHistoryTable(history) {
            const tbody = DOMElements.historyTableBody;
            const noDataRow = DOMElements.historyNoData;
            if (!tbody || !noDataRow) return;

            tbody.innerHTML = ''; // Clear previous rows

            if (history.length === 0) {
                tbody.appendChild(noDataRow); // Show the 'no data' message row
                return;
            }

            // Display history, newest first
            history.slice().reverse().forEach(entry => {
                const row = tbody.insertRow();
                row.className = "text-sm text-gray-700";

                const cellTimestamp = row.insertCell();
                const cellDomain = row.insertCell();
                const cellTitle = row.insertCell();

                cellTimestamp.className = 'px-4 py-2 whitespace-nowrap text-xs text-gray-500';
                cellDomain.className = 'px-4 py-2 whitespace-nowrap font-medium';
                cellTitle.className = 'px-4 py-2';

                try {
                     cellTimestamp.textContent = new Date(entry.timestamp).toLocaleString();
                 } catch (e) {
                     cellTimestamp.textContent = 'Invalid Date';
                 }

                cellDomain.textContent = entry.domain;

                // Display title and URL (make URL clickable)
                const titleText = entry.title || 'No Title';
                const urlLink = document.createElement('a');
                urlLink.href = entry.url;
                urlLink.textContent = entry.url;
                urlLink.target = '_blank'; // Open in new tab
                urlLink.rel = 'noopener noreferrer';
                urlLink.className = 'text-blue-600 hover:underline text-xs block truncate';
                urlLink.title = entry.url; // Show full URL on hover

                cellTitle.textContent = titleText;
                cellTitle.title = titleText; // Show full title on hover
                cellTitle.appendChild(urlLink);

            });
        }


        // --- Toast Notifications ---

        /**
         * Displays a toast notification.
         * @param {string} message - The message to display.
         * @param {'info'|'success'|'warning'|'error'} [type='info'] - The type of toast.
         * @param {number} [duration=4000] - How long the toast stays visible (ms).
         */
        function showToast(message, type = 'info', duration = 4000) {
            if (!DOMElements.toastTemplate || !DOMElements.toastContainer) return;

            const toastClone = DOMElements.toastTemplate.content.cloneNode(true);
            const toastElement = toastClone.querySelector('.toast');
            if (!toastElement) return;

            const messageSpan = toastElement.querySelector('.toast-message');
            const iconSpan = toastElement.querySelector('.toast-icon');
            const closeButton = toastElement.querySelector('.toast-close');

            if (messageSpan) messageSpan.textContent = message;

            let baseBgColor = 'bg-gray-800'; // From template
            let bgColor = 'bg-gray-800';
            let iconName = 'info';
            let iconColor = 'text-blue-300'; // Default icon color

            switch (type) {
                case 'success':
                    bgColor = 'bg-green-600'; iconName = 'check-circle'; iconColor = 'text-white'; break;
                case 'error':
                    bgColor = 'bg-red-600'; iconName = 'alert-circle'; iconColor = 'text-white'; break;
                case 'warning':
                    bgColor = 'bg-yellow-500'; iconName = 'alert-triangle'; iconColor = 'text-white'; break;
                case 'info':
                default:
                    bgColor = 'bg-blue-600'; iconName = 'info'; iconColor = 'text-white'; break;
            }

            toastElement.classList.replace(baseBgColor, bgColor);
            if (iconSpan) {
                 iconSpan.innerHTML = `<i data-lucide="${iconName}" class="lucide w-5 h-5 ${iconColor}"></i>`;
                 lucide.createIcons(); // Render the icon
            }

            if (closeButton) {
                 closeButton.onclick = () => dismissToast(toastElement);
            }

            DOMElements.toastContainer.appendChild(toastElement);

            // Trigger fade-in and slide-in animation
            requestAnimationFrame(() => {
                 toastElement.style.opacity = '1';
                 toastElement.style.transform = 'translateX(0)';
            });

            // Auto dismiss
            const dismissTimeout = setTimeout(() => {
                 dismissToast(toastElement);
            }, duration);

            // Store timeout ID for potential manual dismissal cleanup
             toastElement.dataset.dismissTimeoutId = dismissTimeout;
        }

        /**
         * Dismisses a specific toast element with animation.
         * @param {HTMLElement} toastElement - The toast element to dismiss.
         */
        function dismissToast(toastElement) {
             if (!toastElement) return;

             // Clear auto-dismiss timeout if manually closed
             const timeoutId = toastElement.dataset.dismissTimeoutId;
             if (timeoutId) clearTimeout(timeoutId);


             toastElement.style.opacity = '0';
             toastElement.style.transform = 'translateX(100%)'; // Slide out
             // Remove after animation
             setTimeout(() => toastElement.remove(), 300);
        }

    </script>
</body>
</html>
